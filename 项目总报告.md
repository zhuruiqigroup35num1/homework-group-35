# 创新创业实践课 group35 朱瑞骐 202122202219  
## 注： 每个project文件夹下存放了代码文件和对应project的报告文件  
# 人员分工表：  
## 朱瑞骐    学号：202122202219    负责project:  1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,19,20,22  

# project1：  
# SM3 Naive Birthday Attack  

## 利用生日攻击攻击SM3  
### 背景引入： 哈希碰撞：两个不同的输入值通过哈希后得到相同的哈希值，这对碰撞在伪造等密码学攻击中起到重要作用。 生日攻击：生日攻击是一种密码学攻击手段，所利用的是概率论中生日问题的数学原理。这种攻击手段可用于滥用两个或多个集团之间的通信。此攻击依赖于在随机攻击中的高碰撞概率和固定置换次数（鸽巢原理）。 经典案例：需要统计多少学生才有50%以上的概率找到两个学生同一天生，答案是23人，而达到70人的统计数我们将达到99.9%以上的概率。由此，我们利用这样的生日攻击原理寻求哈希碰撞。我们统计1.17*根号n（n为哈希值的空间大小）数量的输入值，就有50%以上的概率找到一对哈希碰撞
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8   

# 核心代码实现：

![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project1_1.png)  
# 运行结果测试：  
Bit长度是： 26  
sum_time = 1.1805808544158936    
Bit长度为哈希值长度，也就是其空间大小为2^26  
其中sum_time为总时长  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project1_2.png)  

# project2:  
# SM3 Rho环路攻击  
# 背景引入：  
Rho是一种寻找哈希碰撞的算法方案，其思路如下：  
1.选择两个不同的随机输入值，分别为x1和x2。  
2.使用哈希函数h进行迭代计算，即x1 = h(x1)和x2 = h(h(x2))。  
3.检查x1和x2是否相等，如果相等，则找到了一个碰撞。  
4.如果不相等，则重复步骤2和步骤3，直到找到碰撞或者遇到一个循环。  
Rho算法的关键在于探测循环。通过设置快慢指针方法，即慢指针每次进行一次哈希运算，快指针每次进行两次哈希运算，当两个指针相遇时，就检测到了一个循环。在循环中，通过使用迭代函数h进行计算，可以得到相同的结果。  
如果能通过可接受的迭代次数寻找到一个环路，也就是碰撞达成，我们就说对其Rho攻击成功  
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022  

# 核心代码实现：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/0704project2.png)
# 运行示例：  
运行时间： 17.69328s  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/5R5CIU%2470YDGL%60CB499SCZB.png)  

# project3:  
# length extension attack for SM3, SHA256  
## 背景引入：  
长度拓展攻击是一种密码学攻击技术，它利用已知消息与其哈希值，伪造出具有相同哈希值的新消息，而无需知道原始消息的内容。  
在哈希函数的计算过程中，消息的长度是一个重要的输入。攻击者可以根据已知消息的哈希值和长度，构造出一个新的消息，并利用哈希函数的可拓展性，直接计算出新消息的哈希值，从而伪造出一个合法的签名或认证信息，从而达到欺骗的目的。  
该攻击方法可以利用哈希函数的可预测性和在计算哈希值时不会改变消息长度的特性，在不知道原始消息的情况下，利用已知哈希值计算出指定长度的哈希值，以此来伪造消息或者篡改消息。  
理论步骤：  
计算M的哈希值H(M)，得到H(M) = A || B || C || D || E || F || G || H。  
选择一个任意长度的字符串S并计算其哈希值H(S)，得到H(S) = A' || B' || C' || D' || E' || F' || G' || H'。  
将新字符串构造为M' = M || Padding || S，其中Padding为填充使得M'满足64-byte分组长度的值，具体填充方式与SM3算法的填充方式相同。  
重新计算哈希值H(M')，计算方式为将M'分组成64-byte块，然后按照SM3算法计算哈希值，得到H(M') = A || B || C || D || E || F || G || H || H(S)。  
此时得到了M'的哈希值，即可进行伪造和篡改等攻击。  

# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022  

# 核心代码实现：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project_3.png)  
# 运行结果示例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project3_2.png)  

# porject4:  
# SM3 Implementation(software)  
# 背景引入：  
## SM3的实现流程为：  
1.初始化变量 初始化8个32位的寄存器（A、B、C、D、E、F、G、H）为固定的初始值。  
2.数据填充 将待哈希的消息按照规定的填充方式进行数据填充。填充方式包括在消息末尾添加一个"1"和若干个"0"，以及将消息长度表示为64位的大端序整数添加到消息的末尾。  
3.处理消息分组 将填充后的消息划分为若干个分组，每个分组512位，对每个分组进行处理。  
4.压缩函数 压缩函数是SM3算法的核心部分，对每个消息分组进行处理，包括消息扩展、消息搅乱和结果混合。  
  a. 消息扩展：将512位的消息分组扩展为132个32位字的消息扩展序列。  
  b. 消息搅乱：对消息扩展序列进行迭代搅乱，包括有限域上的位运算、非线性变换和轮置换。  
  c. 结果混合：将搅乱后的消息分组结果与寄存器的值进行异或运算，得到新的寄存器值。  
5.更新寄存器值 更新8个寄存器的值，将当前循环的寄存器的值赋给下一个循环。  
6.循环处理 对每个消息分组进行循环处理，直到处理完所有消息分组。  
7.输出结果 将最终的8个寄存器的值按顺序连接起来，得到最终的哈希结果。  
### 效果图示意：
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project4_1.png)  

# 运行环境：    
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022
# 核心代码实现（主要加速了迭代函数的部分和消息扩展搅乱部分）
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project4_2.png)  
# 运行示例（以GROUP为例进行哈希运算）  
运行时间： 0.068s  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project4_3.png)  

# project5:  
# Merkle Tree Implementation  
# 背景引入：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project5_5.png)  
Merkle树是一种哈希树，它是由计算机科学家Ralph Merkle于1987年发明的，并以他的名字命名。Merkle树具有一些独特的特点，使它在网络和加密领域中被广泛使用。  
Merkle树的基本思想是将多个哈希值组合成一个树形结构，使得任何一个哈希值都可以通过计算出它所在的叶节点，并由其它的哈希值逐一地向根节点计算哈希值。这个根节点是一个单一的哈希值，它可以被用作校验这个哈希树上任何一条路径的完整性。  
为了实现这种哈希树结构，需要一些规则：  
1.所有的叶子节点都是数据块的哈希值；  
2.从叶节点开始，每个节点都是其子节点哈希值的哈希值。这样，它们向上成为树的父节点，并重复了同样的计算过程，直到达到根节点，即Merkle树的根哈希值；  
3.如果树的节点数不是2的幂，那么可以使用虚拟节点（选择一个可预期的值，例如0或空哈希值）来填充Merkle树的最后一层。  
Merkle树的特点：  
1.安全：由于哈希函数是不可逆的，因此Merkle树的校验和可以有效的保证数据完整性；  
2.高效：Merkle树的校验和可以在不需要下载所有数据块的情况下快速计算得出，这对于需要快速验证数据完整性的应用程序非常有用。  

## 交易核心：（不）存在性证明
### 存在性证明：  
当有全节点收到这个MSG_MERKLEBLOCK请求之后，利用传过来的交易信息在自己的区块链数据库中进行查询，并把验证路径返回给请求源，SPV节点拿到验证路径之后，再做一次merkle校验  
Alice要证明自己的一笔transaction属于某一区块，需要给出该transcation在某一区块中的序号，然后由叶节点由主链计算回Root节点，并验证Root节点的value  
### 不存在性证明：  
不存在性证明基于交易是排序的，通过对比pre与next确定Merkle根进行存在性证明，并锁定pre和next在Merkle Tree TXID Nodes中的位置，并对相应区块进行不确定性证明  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project5_4.png)  
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  
# 核心代码：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project5_8.png)  

![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project5_9.png)  
# 运行示例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project5_7.png)  

# project6:  
# Impl this Protocol with Actual Network Communication  
# 背景引入：  
"Range Proofs from Hash Functions" 是一种加密学术语汇，指的是使用哈希函数构建范围证明的技术。范围证明是指，对于一个公钥和一个承诺（通常是一种加密方式，用于标识某些内容的哈希值），证明某个值是否落在指定区间内，同时又不暴露任何有关该值的信息。  
范围证明（Range Proof）是一种加密技术，用于证明某个值是否落在指定区间内，同时又不暴露任何有关该值的信息。例如，在加密货币领域中，范围证明技术可用于证明一个交易的输出值是否落在指定区间内，以确保交易不会超出指定范围。但是，由于范围证明需要证明是否在特定范围内，因此需要更多的证明信息，这会增加交易的复杂性和计算成本。  
在这种情况下，使用哈希函数构建范围证明就成为了比较流行的选择。哈希函数（Hash Function）是将任意长度的消息压缩成固定长度消息摘要的函数，通常用于加密、完整性验证和签名等应用。将哈希函数用于范围证明可以提供高效性、简洁性和安全性，这使得它成为构建加密货币或隐私保护应用程序的强大技术工具。使用哈希函数构建范围证明的基本思想是，将哈希函数的输入值与随机数进行混淆并取哈希值进行证明。  
Range Proofs:  
1.选择一个随机数r  
2.计算哈希值h（v | r），其中v是要证明的值  
3.将哈希值h拆分为n个比特（bit）  
4.将h的前k个比特进行公开声明。这些比特称为“置位（commitment）”，用于在后续的阶段中证明单元比特值正确  
5.对于h的其余比特，将它们用来构建证明。例如，可以证明v是否在区域（2m, 2m+1）内，其中m是差异的单元数，其余n-m bits用于构建证明  
6.将证明信息提供给验证者（可能是一个加密货币网络中的节点），验证者可以使用哈希函数和随机数r来重构哈希值h，并检查所提供的证明信息是否正确。  
本协议引入以Alice向Bob证明其age>=21为引入例子  

![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project6_2.png)  
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project6_1.png)  

# 运行示例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project6_3.png)  

# project7(未完成)：  
# Scheme Implmentation（未完成）  
# 背景引入：  
Hyperefficient Credential-Based Range Proofs指的是一种用于验证数字范围证明的技术。简单来说，数字范围证明是一种保护隐私的技术，它允许用户在不透露实际数字的情况下证明某个数字在特定的范围内。这种证明在许多应用场景中非常有用，例如电子现金、匿名投票、身份验证等等。  
Hyperefficient Credential-Based Range Proofs的实现方式主要包括以下几个步骤：  
1.设置参数：在使用数字范围证明进行验证之前，需要首先设置一些参数，包括待证明的数字范围、公钥和私钥等。  
2.生成凭证：凭证是数字范围证明过程中的重要组成部分。利用一些密码学技术，可以生成一些凭证用于验证数字范围。在此过程中，生成的凭证可以用于多次验证，而不需要暴露实际数字。  
3.验证数字范围：使用生成的凭证和设置的参数，验证数字是否在给定的范围内。这个过程会返回一个结果，表明数字是否在指定范围内。  
Hyperefficient Credential-Based Range Proofs的实现方式主要基于以下技术实现：  
1.零知识证明技术：这是密码学中的一种技术，它可以在不泄露任何有关证明的信息的前提下，证明某个陈述是正确的。  
2.双线性配对技术：这是一种密码学技术，它将两个群之间的乘积映射到另一个群中，并且满足乘法和加法的性质，可以用于实现数字范围证明。  
3.承诺方案技术：这是一种密码学技术，可以将数字“承诺”到未来，并且只能在未来的某个时刻才能揭示数字的真实值，用于实现数字范围证明中的凭证生成。  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project7_2.png)  

# 注：  
## 本问题没有完全完成，只能给出部分尝试写出的代码：  
## 利用种子生成哈希的部分可能的过程：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project7_1.png)  

# project8:  
# Impl AES With ARM Instruction
# 背景引入：  
## ARM指令集：  
ARM指令集是一种被广泛应用于嵌入式系统和移动设备的低功耗处理器架构。ARM指令集被设计为简洁、高效和灵活，能够满足不同类型的应用需求。  
ARM指令集包含多种指令，可以执行基本的算术和逻辑操作，访问和操作内存，进行控制流转移等。ARM指令可以分为数据处理指令、加载/存储指令、分支和跳转指令等。具体的指令格式和操作方式可以根据不同的ARM架构进行扩展和变化。  
ARM指令集的特点包括紧凑、低功耗和高性能。紧凑的指令表示形式可以减小指令存储空间和流量，并提高指令缓存的命中率。低功耗的设计使得ARM处理器在电池供电设备中具有较长的续航时间。高性能的特点则使得ARM处理器适用于许多计算密集型和实时应用。  
ARM指令集还具有可扩展性和可移植性。不同的ARM处理器可以支持不同的指令集扩展和优化，以满足特定应用领域的需求。同时，ARM处理器可以使用不同的编译器和开发工具链进行开发，使得代码在不同的ARM架构上具有良好的移植性和兼容性。  
总而言之，ARM指令集是一种用于嵌入式系统和移动设备的低功耗处理器架构，具有高性能、低功耗和可扩展性的特点。  
## AES：  
AES是SPN结构的对称加密算法，其步骤为：  
1.密钥生成：根据安全要求，生成一个128、192或256位的密钥  
2.明文填充：如果明文长度不是块长度的整数倍，则需要进行填充  
3.初始轮加：将明文分为块，使用密钥进行第一次加密，得到密文  
4.四轮变换：循环执行四轮变换，每一轮由四个步骤组成：
a.字节代替（SubBytes）：将每个字节替换为预定义的值  
b.行移位（ShiftRows）：按照特定规则移动每行中的字节位置  
c.列混淆（MixColumns）：对每列进行逐位乘和加操作  
d.轮密钥加（AddRoundKey）：将每个字节与该轮使用的密钥相关联的值进行异或操作  
最后一轮：执行最后一轮变换，但不包括列混淆步骤  
密文输出：将最后一轮得到的密文输出  
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022 && Keil  
# 注：  
此project基于Keil仿真环境  
没有学明白怎么用ARM指令集写，只能给出C语言的代码  
附带了C源代码和Keil上的代码  
# 核心代码：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project8_1.png)  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project8_2.png)  

# 运行示例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project8_3.png)  

# project9:  
# Impl AES SM4(software)  
# 背景引入：  
## AES：  
AES是一种基于SPN结构的对称加密算法，有128bit，192bit，256bit三种长度的工作模式  
其加密步骤为：  
1.密钥生成：根据安全要求，生成一个128、192或256位的密钥  
2.明文填充：如果明文长度不是块长度的整数倍，则需要进行填充  
3.初始轮加：将明文分为块，使用密钥进行第一次加密，得到密文  
4.四轮变换：循环执行四轮变换，每一轮由四个步骤组成：  
a.字节代替（SubBytes）：将每个字节替换为预定义的值  
b.行移位（ShiftRows）：按照特定规则移动每行中的字节位置  
c.列混淆（MixColumns）：对每列进行逐位乘和加操作  
d.轮密钥加（AddRoundKey）：将每个字节与该轮使用的密钥相关联的值进行异或操作  
最后一轮：执行最后一轮变换，但不包括列混淆步骤  
密文输出：将最后一轮得到的密文输出  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_3.png)  

## SM4:  
M4 算法是一种基于Feistel结构的分组密码算法。其分组长度为 128bit，密钥长度也为 128bit  
加密算法与密钥扩展算法均采用 32 轮非线性迭代结构，以字（32 位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F  
SM4 算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_1.png)  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_2.png)  

# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022  

# 核心代码：  
## AES:  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_4.png)  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_5.png)  

## SM4：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_8.jpg)  

# 运行示例：  
## AES：  
### 加密学号：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_6.png)  
### 时间测试：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_7.png)  

## SM4:  
### 加密学号（包含时间测试）：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project9_9.jpg)  

# project10:  
# Impl This Deduce Technique in Ethereum with ECDSA  
# 背景引入:  
ECDSA（Elliptic Curve Digital Signature Algorithm）是基于椭圆曲线密码学的数字签名算法  
ECDSA使用椭圆曲线上的点进行密钥生成、签名和验证  
## 具体步骤：  
密钥生成：选择一个椭圆曲线作为密码算法的基础，并随机选取一个私钥（一个整数）。接着，通过使用椭圆曲线上的点乘法来计算对应的公钥（一个曲线上的点）  
签名生成：在进行数字签名之前，需要先对原始数据进行哈希处理，以减小数据量并提高安全性。然后，选择一个随机数作为签名的私钥（一个整数），并使用该私钥和原始数据的哈希值来计算签名的数字。签名的数字由两个组成：一个称为r值，代表椭圆曲线上的点的x坐标；另一个称为s值，是根据私钥、哈希值和r值计算得出的  
签名验证：接收到签名的一方可以使用发送方的公钥、原始数据的哈希值以及签名的数字来验证签名的有效性。在验证过程中，将使用公钥和哈希值来重新计算r值，并将其与签名中的r值进行比较。如果两者相等，则表示签名有效  
## 优点  
ECDSA相对于其他签名算法的优势包括较小的密钥尺寸、较快的运算速度和较低的资源消耗。由于这些特点，ECDSA在资源受限的环境中得到了广泛应用，例如智能卡和物联网设备  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project10_1.png)  

# 运行环境：    
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project10_2.png)  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project10_3.png)  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project10_6.png)  

# 运行示例：
## 对学号签名：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project10_5.png)  

# project11：  
# Impl SM2 with RFC6979  
# 背景引入：  
## RFC6979文档：www.gmbz.org.cn/main/viewfile/20180108015515787986.html  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project11_1.jpg)  
## SM2算法：  
SM2算法是我国自主研发的一种椭圆曲线公钥密码算法，也是我国首个自主拥有完全自主知识产权的公钥密码算法。SM2算法被广泛应用于数字签名、密钥交换等安全领域，是我国在国际密码领域首次发表的公钥密码算法标准。  
SM2算法基于椭圆曲线密码体制（ECC），使用国家密码管理局公布的SM2曲线作为基础曲线，具有很高的安全性和效率。SM2算法可以实现数字签名、密钥协商和密钥交换等功能，还可以应用于密码卡、智能卡等硬件设备。  
### 算法步骤：  
1.密钥生成：  
（1）选择SM2椭圆曲线系统参数  
（2）选取一个随机数作为私钥，并通过椭圆曲线方程计算出公钥  
（3）输出私钥和公钥  
2.加密：  
（1）选择一个随机数作为临时私钥  
（2）使用SM2椭圆曲线方程计算出临时公钥  
（3）将明文转换成一个点，并加上随机数生成的点作为加密数据  
（4）计算出密文  
3.解密：  
（1）使用私钥计算出临时公钥  
（2）使用SM2椭圆曲线方程计算出加密数据中随机数生成的点  
（3）使用加密数据中的点减去临时生成的点得到明文  
4.数字签名：  
（1）计算出消息的哈希值  
（2）选择一个随机数作为临时私钥  
（3）计算出临时公钥  
（4）计算出签名值  

![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project11_2.png)  

# 运行环境：   
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project11_4.png)  

# 运行示例：  
## 以加密学号为例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project11_5.png)  

# project12:  
# Verify the Above Pitfalls with Proof-of-concept Code  
# 背景引入：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_4.png)  
用代码验证上述陷阱  
## 泄露K  
直接利用公式恢复即可  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_5.png)  
## Reusing K  
### 重复使用K的时候，直接用下图公式即可恢复对应私钥  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_1.png)  
## Reusing K by Different Users  
### 不同使用者使用相同K的时候，可以根据签名值恢复私钥  
攻击原理如下图所示：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_3.png)  
## Same d and K with ECDSA  
### 和ECDSA使用相同的私钥d和K的时候，可以根据两者的签名进行私钥恢复  
攻击原理如下图所示：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_2.png)  

# 运行环境：   
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
## 处理泄露K的方案：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_6.png)  
## 处理Reusing K的方案：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_7.png)  
## 处理Reusing K by Different Users的方案：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_8.png)  
## 处理Same d and K with ECDSA的方案：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_8.png)  

# 运行示例：  
## 以签名消息为学号为例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project12_10.png)  

# project13:  
# Impl the Above ECMH Scheme  
# 背景引入：  
ECMH结构是指Elliptic Curve Modular Hash结构，是一种在密码学中用于实现哈希函数的结构。它是由一组密钥、一个哈希函数以及一个加密算法组成的，并利用椭圆曲线进行加密。ECMH结构具有安全性高、计算速度快等优点，被广泛应用于数字签名、数据加密等领域。  
要将hash函数的值转换到椭圆曲线上，然后将其加法转化为椭圆曲线上点与点之间的加法  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project13_1.png)  

# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
## 椭圆曲线上的点群加法：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project13_2.png)  
## ECMH结构：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project13_3.png)  
## 测试数据：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project13_4.png)  

# 运行示例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project13_5.png)  

# project14:  
# Implement a PGP Scheme with SM2  
# 背景引入：  
PGP (Pretty Good Privacy) 是一种加密系统，它采用对称加密和非对称加密的结合来实现安全通信。PGP 最初由 Phil Zimmermann 开发，并于1991年发布  
PGP 使用非对称加密来创建密钥对，包括公钥和私钥。公钥是可以公开分享的，可以用来加密消息和验证数字签名。私钥只有持有者知道，用于解密消息和生成数字签名  
PGP 还使用对称加密来加密实际的消息。在对称加密中，发送方使用同一个密钥加密和解密消息。这个密钥也被称为会话密钥。通常，发送方使用对方的公钥来加密会话密钥，并将其发送给接收方。接收方使用自己的私钥来解密会话密钥，然后使用该密钥来解密消息  
最后，PGP 还支持数字签名，在消息上添加数字签名后，就可以确保消息的真实性和完整性。这是通过使用发送方的私钥来生成数字签名来实现的，任何拥有发送方公钥的人都可以验证该数字签名  
### 本次使用SM2作为非对称加密部分用来创建密钥对，使用AES作为对称加密部分  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project14_1.png)  

# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
## 加解密部分：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project14_2.png)  
## 发送与接收方：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project14_3.png)  

# 运行示例：  
## 以加密学号为例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project14_4.png)  

# project15:  
# Implement SM2 2P Sign with Real Network Communication  
# 背景引入：  
SM2双方签名是指使用SM2算法进行双方身份认证和消息完整性验证的过程。在这个过程中，通信双方各自生成一对公私钥，并将自己的公钥发送给对方。然后，当一方需要向另一方发送消息时，它使用自己的私钥对消息进行签名，并将签名信息发送给对方。接收方使用发件人的公钥进行验签，以确保收到的消息是完整的、未被篡改过的，并确认发件人的身份  
SM2双方签名采用基于椭圆曲线离散对数问题的公钥密码学算法，具有高强度、高安全性、高效性等特点，适用于各种网络通信环境。双方签名的过程安全可靠，能够有效地防止假冒和信息被篡改的情况  
具体步骤如下：  
1.生成密钥对：通信双方各自生成自己的公私钥对。其中，私钥是一串随机的数值，只有持有者才能访问；公钥是由私钥生成的一串数值，可以公开  
2.公钥交换：通信双方将自己的公钥发送给对方，以进行身份验证和消息完整性验证。在发送公钥的过程中，通信双方需要进行认证，以确保对方收到的公钥是真实有效的  
3.消息签名：当一方需要向另一方发送消息时，它使用自己的私钥对消息进行签名。签名的过程主要是对消息进行哈希运算，并使用私钥生成数字签名  
4.消息验签：接收方在收到消息后，使用发件人的公钥对消息进行验签。验签的过程主要是对消息进行哈希运算，并验证数字签名与哈希值是否匹配，以确保消息的完整性和真实性  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project15_1.png)  

# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8  

# 核心代码：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project15_2.png)  

# 运行示例：  
## 以学号为例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project15_3.png)  

# project16:  
# 比较Firefox和谷歌的记住密码插件的实现区别  
# 未完成  

# project17:  

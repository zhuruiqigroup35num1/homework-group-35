# 创新创业实践课 group35 朱瑞骐 202122202219  
## 注： 每个project文件夹下存放了代码文件和对应project的报告文件  
# 人员分工表：  
## 朱瑞骐    学号：202122202219    负责project:  1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,19,20,22  

# project1：  
# SM3 Naive Birthday Attack  

## 利用生日攻击攻击SM3  
### 背景引入： 哈希碰撞：两个不同的输入值通过哈希后得到相同的哈希值，这对碰撞在伪造等密码学攻击中起到重要作用。 生日攻击：生日攻击是一种密码学攻击手段，所利用的是概率论中生日问题的数学原理。这种攻击手段可用于滥用两个或多个集团之间的通信。此攻击依赖于在随机攻击中的高碰撞概率和固定置换次数（鸽巢原理）。 经典案例：需要统计多少学生才有50%以上的概率找到两个学生同一天生，答案是23人，而达到70人的统计数我们将达到99.9%以上的概率。由此，我们利用这样的生日攻击原理寻求哈希碰撞。我们统计1.17*根号n（n为哈希值的空间大小）数量的输入值，就有50%以上的概率找到一对哈希碰撞
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：IDLE 3.8   

# 核心代码实现：

![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project1_1.png)  
# 运行结果测试：  
Bit长度是： 26  
sum_time = 1.1805808544158936    
Bit长度为哈希值长度，也就是其空间大小为2^26  
其中sum_time为总时长  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project1_2.png)  

# project2:  
# SM3 Rho环路攻击  
# 背景引入：  
Rho是一种寻找哈希碰撞的算法方案，其思路如下：  
1.选择两个不同的随机输入值，分别为x1和x2。  
2.使用哈希函数h进行迭代计算，即x1 = h(x1)和x2 = h(h(x2))。  
3.检查x1和x2是否相等，如果相等，则找到了一个碰撞。  
4.如果不相等，则重复步骤2和步骤3，直到找到碰撞或者遇到一个循环。  
Rho算法的关键在于探测循环。通过设置快慢指针方法，即慢指针每次进行一次哈希运算，快指针每次进行两次哈希运算，当两个指针相遇时，就检测到了一个循环。在循环中，通过使用迭代函数h进行计算，可以得到相同的结果。  
如果能通过可接受的迭代次数寻找到一个环路，也就是碰撞达成，我们就说对其Rho攻击成功  
# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022  

# 核心代码实现：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/0704project2.png)
# 运行示例：  
运行时间： 17.69328s  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/5R5CIU%2470YDGL%60CB499SCZB.png)  

# project3:  
# length extension attack for SM3, SHA256  
## 背景引入：  
长度拓展攻击是一种密码学攻击技术，它利用已知消息与其哈希值，伪造出具有相同哈希值的新消息，而无需知道原始消息的内容。  
在哈希函数的计算过程中，消息的长度是一个重要的输入。攻击者可以根据已知消息的哈希值和长度，构造出一个新的消息，并利用哈希函数的可拓展性，直接计算出新消息的哈希值，从而伪造出一个合法的签名或认证信息，从而达到欺骗的目的。  
该攻击方法可以利用哈希函数的可预测性和在计算哈希值时不会改变消息长度的特性，在不知道原始消息的情况下，利用已知哈希值计算出指定长度的哈希值，以此来伪造消息或者篡改消息。  
理论步骤：  
计算M的哈希值H(M)，得到H(M) = A || B || C || D || E || F || G || H。  
选择一个任意长度的字符串S并计算其哈希值H(S)，得到H(S) = A' || B' || C' || D' || E' || F' || G' || H'。  
将新字符串构造为M' = M || Padding || S，其中Padding为填充使得M'满足64-byte分组长度的值，具体填充方式与SM3算法的填充方式相同。  
重新计算哈希值H(M')，计算方式为将M'分组成64-byte块，然后按照SM3算法计算哈希值，得到H(M') = A || B || C || D || E || F || G || H || H(S)。  
此时得到了M'的哈希值，即可进行伪造和篡改等攻击。  

# 运行环境：  
硬件环境：  
处理器：AMD Ryzen 7 5800H with Radeon Graphics   
CPU： 3.20 GHz内存：16.0 GB (15.9 GB 可用)  
软件环境：  
操作系统：win11   
编译器：Visual Studio2022  

# 核心代码实现：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project_3.png)  
# 运行结果示例：  
![Image_test](https://github.com/zhuruiqigroup35num1/homework-group-35/blob/main/image/project3_2.png)
